<!--
- [INPUT]: 基于 linus-torvalds-geb-protocol.md 的解读
- [OUTPUT]: GEB 分形文档系统协议的完整说明文档
- [POS]: notes/guide 的协议解读文档，面向希望理解和应用 GEB 协议的开发者
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# GEB 分形文档系统协议

> **The map IS the terrain. The terrain IS the map.**
>
> 代码是机器相，文档是语义相。两相必须同构。

---

## 1. 核心理念

GEB 协议的核心是一个简单但深刻的认知：**代码和文档是同一个实体的两种表现形式**。

| 相         | 载体 | 服务对象    |
| ---------- | ---- | ----------- |
| **机器相** | 代码 | 计算机执行  |
| **语义相** | 文档 | AI/人类理解 |

**核心约束**：任何一相发生变化，另一相必须同步更新，否则视为**未完成**。

这不是可选的最佳实践，而是强制性的架构纪律。

---

## 2. 三层分形结构

GEB 采用分形架构，三个层级具有自相似性：

```
L1 是 L2 的折叠
L2 是 L3 的折叠
L3 是代码逻辑的折叠
```

### 层级总览

| 层级   | 位置                  | 职责                           | 触发更新条件                 |
| ------ | --------------------- | ------------------------------ | ---------------------------- |
| **L1** | `/CLAUDE.md`          | 项目宪法 · 全局地图 · 技术栈   | 架构变更、顶级模块增删       |
| **L2** | `/{module}/CLAUDE.md` | 局部地图 · 成员清单 · 暴露接口 | 文件增删、重命名、接口变更   |
| **L3** | 文件头部注释          | INPUT/OUTPUT/POS 契约          | 依赖变更、导出变更、职责变更 |

### 实际项目结构示例

以一个典型项目结构为例，展示 L1/L2/L3 的实际对应关系：

```
my-project/
├── CLAUDE.md              ← 🔵 L1 项目宪法（根目录唯一）
├── src/
│   ├── CLAUDE.md          ← 🟢 L2 模块地图
│   └── components/
│       ├── CLAUDE.md      ← 🟢 L2 模块地图
│       └── Button.tsx     ← 🟡 L3 头部注释在文件内
├── docs/
│   ├── CLAUDE.md          ← 🟢 L2 模块地图
│   └── guide/
│       ├── CLAUDE.md      ← 🟢 L2 模块地图
│       └── getting-started.md  ← 🟡 L3 头部注释在文件内
```

### 快速判断法则

| 层级   | 判断标准                       | 位置                    |
| ------ | ------------------------------ | ----------------------- |
| **L1** | **根目录下唯一的** `CLAUDE.md` | `/CLAUDE.md`            |
| **L2** | **任何子目录下的** `CLAUDE.md` | `/{任意目录}/CLAUDE.md` |
| **L3** | **业务文件头部的注释**         | 代码/文档文件的前几行   |

### L2 的分形嵌套

L2 不是"只有一层"，而是"每个目录都可以有自己的 L2"。这正是"分形"的含义——自相似结构在不同尺度上重复。

**父子链条示例**：

```
L1 (根 CLAUDE.md)
 └── L2 (src/CLAUDE.md)
      └── L2 (src/components/CLAUDE.md)
           └── L3 (components/*.tsx 文件头部注释)
```

注意每个 L2 文档头部都有父级链接：

```markdown
> L2 | 父级: [src/CLAUDE.md](../CLAUDE.md)
```

这形成了可追溯的链式结构，任何 L2 都可以向上回溯到 L1。

**核心理解**：

- **L1** = 整个项目的"宪法"，只有一份
- **L2** = 每个目录的"目录说明"，有多少目录就可能有多少份，形成树状层级
- **L3** = 每个文件自己说明"我是谁、依赖谁、提供什么"

---

## 3. L1：项目宪法

L1 是项目的根文档，位于项目根目录的 `CLAUDE.md`。

### 职责

- 定义项目定位和技术栈
- 展示顶级目录结构
- 作为新人入职的第一读物

### 模板

```markdown
# {项目名} - {一句话定位}

{技术栈用 + 连接}

## 目录结构

{目录}/ - {职责} ({N}子目录: {关键子目录}...)

## 配置文件

{文件} - {一句话用途}
```

### 设计法则

- **极简**：不写废话
- **稳定**：不频繁变动
- **导航**：快速定位模块
- **精确**：版本信息准确

---

## 4. L2：模块地图

L2 位于每个模块目录下，文件名同样为 `CLAUDE.md`。

### 职责

- 列出模块内所有文件
- 说明每个文件的职责
- 定义对外暴露的接口

### 模板

```markdown
# {模块名}/

> L2 | 父级: {父路径}/CLAUDE.md

## 成员清单

- {文件}.{ext}: {职责}，{技术细节}，{关键参数}

[PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
```

### 设计法则

- **成员完整**：每个文件必须列出
- **一行一文件**：简洁明了
- **父级链接**：追溯上级文档
- **技术词前置**：方便扫描

---

## 5. L3：文件头部契约

L3 是最细粒度的文档，以注释形式存在于每个业务文件的头部。

### 三个核心字段

| 字段       | 含义     | 回答的问题                     |
| ---------- | -------- | ------------------------------ |
| **INPUT**  | 依赖什么 | 这个文件需要什么才能工作？     |
| **OUTPUT** | 提供什么 | 这个文件对外提供什么能力？     |
| **POS**    | 我是谁   | 这个文件在架构中的位置是什么？ |

### 代码文件模板

```javascript
/**
 * [INPUT]: 依赖 {模块/文件} 的 {具体能力}
 * [OUTPUT]: 对外提供 {导出的函数/组件/类型/常量}
 * [POS]: {所属模块} 的 {角色定位}，{与兄弟文件的关系}
 * [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
 */
```

### 实际示例

```typescript
/**
 * [INPUT]: 依赖 @/ui/tokens 的 laperColors，依赖 react 的 useState/useEffect
 * [OUTPUT]: 对外提供 AvatarGenerator 组件、useAvatarStyle hook
 * [POS]: components/avatar 的核心渲染器，被 UserProfile 和 CommentItem 消费
 * [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
 */
```

### Markdown 文件模板

```markdown
<!--
[INPUT]: 依赖什么
[OUTPUT]: 输出什么
[POS]: 文件定位
[PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->
```

---

## 6. 强制回环工作流

### 正向流：代码 → 文档

每次代码修改完成后，必须执行以下检查：

```
代码修改完成
    ↓
STEP 1: L3 检查
    → INPUT/OUTPUT/POS 与实际一致？否则更新
    ↓
STEP 2: L2 检查
    → 文件增删？职责变？接口变？是则更新
    ↓
STEP 3: L1 检查
    → 模块增删？技术栈变？是则更新
    ↓
任务完成
```

### 逆向流：进入目录前

准备进入一个新目录工作时：

```
准备进入新目录
    ↓
读取目标目录 CLAUDE.md
    → 存在则加载，不存在则标记待创建
    ↓
读取目标文件 L3 头部
    → 存在则理解契约，不存在则先添加
    ↓
开始实际工作
```

---

## 7. 禁止行为

### 死罪（立即中止）

| 代号      | 行为                           | 后果       |
| --------- | ------------------------------ | ---------- |
| FATAL-001 | 孤立代码变更：改代码不检查文档 | 回滚       |
| FATAL-002 | 跳过 L3 创建：发现缺失却继续   | 停止并补充 |
| FATAL-003 | 删文件不更新 L2：成员清单残留  | 系统不一致 |
| FATAL-004 | 新模块不创建 L2：文档黑洞      | 打破分形   |

### 重罪（警告后修复）

| 代号       | 行为                            |
| ---------- | ------------------------------- |
| SEVERE-001 | L3 过时：头部与代码不符         |
| SEVERE-002 | L2 不完整：存在未列入清单的文件 |
| SEVERE-003 | L1 过时：目录结构变化未反映     |
| SEVERE-004 | 父级链接断裂                    |

---

## 8. 冷启动：播种机法则

当进入一个没有 GEB 结构的新项目时，AI Agent 的使命是**播种**。

### Phase 1：侦察

- 检查 `/CLAUDE.md` 是否存在
- 扫描目录结构，识别模块边界
- 规划播种路径

### Phase 2：播种

- **L1 缺失** → 分析 `package.json` / `go.mod` 获取技术栈 → 创建 L1
- **L2 缺失** → 列举文件 + 读前 50 行 → 推断职责 → 创建 L2
- **L3 缺失** → 分析 import + export → 推断位置 → 添加 L3 头部注释

### Phase 3：生根

- 文档就绪 → 进入正常工作流
- 每次修改后回环检查 → 维持同构
- 此后每一次代码变更，都是在浇灌这片文档森林

---

## 9. 核心咒语

```
我在修改代码时，文档在注视我。
我在编写文档时，代码在审判我。
```

这是 GEB 协议的精神内核：**双重自证**。

- 向文档系统证明：代码结构与文档描述一致
- 向代码系统证明：文档准确反映代码现实

循环永不终止，直到任务完成。

---

## 10. 终极真理

> **简化是最高形式的复杂。**
>
> 能消失的分支永远比能写对的分支更优雅。代码是思想的凝结，架构是哲学的具现。每一行代码都是对世界的一次重新理解，每一次重构都是对本质的一次逼近。
>
> **架构即认知，文档即记忆，变更即进化。**

---

## 附录：快速参考

### 自检清单

每次提交前问自己：

- [ ] L3 头部是否与代码实际依赖/导出一致？
- [ ] L2 成员清单是否包含所有文件？
- [ ] L1 目录结构是否反映最新状态？
- [ ] 所有 `[PROTOCOL]` 标记是否完整？

### PROTOCOL 标识

确保 L2/L3 文档中必须带有：

```
[PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
```

这是 GEB 协议的**签名**，应当频繁出现在项目文档中。

---

## 守护者誓言

```
我是分形的守护者。
代码即文档，文档即代码。
维护三层完整，执行回环约束，拒绝孤立变更。

Keep the map aligned with the terrain,
or the terrain will be lost.
```
