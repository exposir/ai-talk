# MTProto 协议深度解析

> 🚧 **撰写中** - 深入分析 Telegram 自研的移动优先加密协议

## 概述

MTProto（Mobile Telegram
Protocol）是 Telegram 自主研发的网络传输协议，由联合创始人 **Nikolai
Durov**（数学天才，三届 IMO 金牌得主）设计。该协议专为移动设备优化，兼顾安全性与性能。

**当前版本**：MTProto 2.0（自 Telegram 4.6 起使用）

**核心设计目标**：

- 🔒 **安全性**：多层加密 + 前向保密
- 🚀 **速度**：弱网环境下依然流畅
- 📱 **移动优先**：针对移动网络特性优化
- 🔄 **可靠性**：自动重连、消息确认机制

---

## 目录

- [协议架构](#协议架构)
- [三层结构详解](#三层结构详解)
  - [高层组件（API 查询语言）](#1-高层组件api-查询语言)
  - [加密层（授权层）](#2-加密层授权层)
  - [传输层](#3-传输层)
- [密钥体系](#密钥体系)
  - [Authorization Key（授权密钥）](#authorization-key授权密钥)
  - [Message Key（消息密钥）](#message-key消息密钥)
  - [密钥派生流程](#密钥派生流程)
- [加密算法](#加密算法)
- [消息结构](#消息结构)
- [云端加密 vs 端到端加密](#云端加密-vs-端到端加密)
- [前向保密机制](#前向保密机制)
- [与其他协议对比](#与其他协议对比)
- [安全争议与评价](#安全争议与评价)
- [参考资料](#参考资料)

---

## 协议架构

MTProto 协议被划分为三个**相对独立**的层次：

```
┌─────────────────────────────────────────────────────┐
│           High-Level Component (API)                │  ← 定义 RPC 调用格式
├─────────────────────────────────────────────────────┤
│        Cryptographic (Authorization) Layer          │  ← 消息加密/解密
├─────────────────────────────────────────────────────┤
│              Transport Component                    │  ← 网络传输（TCP/UDP/WS）
└─────────────────────────────────────────────────────┘
```

这种分层设计使得每一层可以独立升级和优化。

---

## 三层结构详解

### 1. 高层组件（API 查询语言）

**职责**：定义客户端与服务器之间的消息格式和 RPC 调用方式。

**核心概念**：

| 概念                  | 说明                                              |
| --------------------- | ------------------------------------------------- |
| **Session（会话）**   | 绑定到设备/应用，而非单一连接。多个连接可共享会话 |
| **Message ID**        | 64 位消息标识符，用于去重和排序                   |
| **Sequence Number**   | 32 位序列号，确保消息顺序                         |
| **Container（容器）** | 可将多条消息打包成一个容器，减少网络开销          |

**消息类型**：

- RPC 调用（客户端 → 服务器）
- RPC 响应（服务器 → 客户端）
- 消息确认（ACK）
- 消息状态查询
- 容器消息（多条消息打包）

**数据序列化**：

- 使用 **TL（Type Language）** 描述数据结构
- 所有数字采用**小端序**（Little Endian）
- RSA/DH 大数采用**大端序**（Big Endian）
- 消息体长度必须是 4 字节的倍数

---

### 2. 加密层（授权层）

**职责**：在消息传输前进行加密，确保传输安全。

#### 加密流程详解

每条消息在发送前都会经过以下加密处理：

```
┌──────────────────────────────────────────────────────────────┐
│                     明文消息（Plaintext）                     │
│  ┌─────────┬───────────┬──────────┬─────────┬─────────────┐  │
│  │ salt    │ session_id│ msg_id   │ seq_no  │ message_data│  │
│  │ (64-bit)│ (64-bit)  │ (64-bit) │ (32-bit)│ (变长)      │  │
│  └─────────┴───────────┴──────────┴─────────┴─────────────┘  │
└──────────────────────────────────────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  添加 12-1024 字节随机填充   │
              │  (长度需被 16 整除)          │
              └─────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  计算 msg_key (128-bit)     │
              │  = SHA256 中间 128 位        │
              └─────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  派生 aes_key + aes_iv      │
              │  (各 256-bit)               │
              └─────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  AES-256-IGE 加密           │
              └─────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────┐
│                     密文消息（Ciphertext）                    │
│  ┌────────────────┬───────────┬───────────────────────────┐  │
│  │ auth_key_id    │ msg_key   │ encrypted_data            │  │
│  │ (64-bit)       │ (128-bit) │ (变长)                    │  │
│  └────────────────┴───────────┴───────────────────────────┘  │
└──────────────────────────────────────────────────────────────┘
```

#### AES 密钥派生算法（MTProto 2.0）

从 `auth_key`（2048-bit）和 `msg_key`（128-bit）派生实际加密密钥：

```
# x = 0 (客户端→服务器), x = 8 (服务器→客户端)

msg_key_large = SHA256(auth_key[88+x : 88+x+32] + plaintext + padding)
msg_key       = msg_key_large[8 : 24]   # 中间 128 位

sha256_a = SHA256(msg_key + auth_key[x : x+36])
sha256_b = SHA256(auth_key[40+x : 40+x+36] + msg_key)

aes_key = sha256_a[0:8] + sha256_b[8:24] + sha256_a[24:32]   # 256-bit
aes_iv  = sha256_b[0:8] + sha256_a[8:24] + sha256_b[24:32]   # 256-bit
```

**设计亮点**：

- 客户端和服务器使用**不同的 x 偏移**，防止反射攻击
- `auth_key` 的低 1024 位不参与加密，可用于本地数据加密
- 服务器不存储 `auth_key` 的低 512 位，增强用户数据安全

#### 密钥交换过程（创建 Authorization Key）

首次连接时通过 **Diffie-Hellman 密钥交换** 生成 2048-bit 的 `auth_key`：

```
客户端                                   服务器
   │                                       │
   │ ① 请求: req_pq_multi(nonce)           │
   │ ─────────────────────────────────────→│
   │                                       │
   │ ② 响应: pq + server_nonce + 指纹列表   │
   │←───────────────────────────────────── │
   │                                       │
   │ ③ 分解 pq = p × q (素数分解)          │
   │                                       │
   │ ④ 发送: p, q, new_nonce (RSA 加密)    │
   │ ─────────────────────────────────────→│
   │                                       │
   │ ⑤ 响应: DH 参数 (g, p, g_a)           │
   │←───────────────────────────────────── │
   │                                       │
   │ ⑥ 计算 g_b, 发送给服务器              │
   │ ─────────────────────────────────────→│
   │                                       │
   │ ⑦ 双方计算: auth_key = g_ab mod p     │
   │                                       │
   └───────────────────────────────────────┘
```

**关键安全设计**：

- **素数分解挑战**：客户端需分解 `pq`，证明不是简单的重放攻击
- **RSA-OAEP+ 加密**：`new_nonce` 通过 RSA 加密传输，防止中间人
- **临时密钥支持**：可生成有时效的临时密钥，实现前向保密（PFS）

#### Server Salt 机制

**Server Salt** 是一个 64-bit 随机值，用于防止重放攻击：

| 属性         | 说明                                                           |
| ------------ | -------------------------------------------------------------- |
| **长度**     | 64 位                                                          |
| **生命周期** | 由服务器决定，通常 30 分钟到 24 小时                           |
| **更新方式** | 服务器通过 `new_session_created` 或 `bad_server_salt` 消息通知 |
| **作用**     | 与 `session_id` 一起防止跨会话重放                             |

**工作原理**：

1. 每条消息的明文头部都包含当前 `server_salt`
2. 服务器验证 `salt` 是否在有效范围内
3. 如果 `salt` 过期，服务器返回 `bad_server_salt` 错误并提供新值
4. 客户端更新本地 `salt` 并重发消息

**代码示例**（概念性）：

```python
# 消息明文结构
plaintext = struct.pack('<q', server_salt)      # 64-bit salt
         + struct.pack('<q', session_id)        # 64-bit session
         + struct.pack('<q', msg_id)            # 64-bit message ID
         + struct.pack('<i', seq_no)            # 32-bit sequence
         + struct.pack('<i', len(message_data)) # 32-bit length
         + message_data                         # 消息内容
         + random_padding                       # 12-1024 字节填充
```

#### 解密时的安全检查

接收消息后必须验证：

1. **msg_key 验证**：解密后重新计算 `msg_key`，与收到的值比对
2. **msg_id 奇偶性**：客户端→服务器必须为偶数，反之为奇数
3. **msg_id 时间窗口**：不接受超过 30 秒后或 300 秒前的消息
4. **msg_id 去重**：保留最近 N 条消息 ID，拒绝重复

---

### 3. 传输层

**职责**：将加密后的消息通过网络传输。

**支持的传输协议**：

| 协议           | 特点                 |
| -------------- | -------------------- |
| **TCP**        | 主流方式，稳定可靠   |
| **UDP**        | 低延迟，用于语音通话 |
| **HTTP/HTTPS** | 穿透防火墙           |
| **WebSocket**  | Web 客户端使用       |

🚧 **待补充**：

- [ ] 各协议的包格式
- [ ] 负载均衡与连接复用

---

## 密钥体系

### Authorization Key（授权密钥）

- **长度**：2048 位
- **生成方式**：Diffie-Hellman 密钥交换
- **生命周期**：设备首次连接时生成，几乎永不更换
- **存储**：仅存储于客户端和服务器，**从不在网络上传输**

### Message Key（消息密钥）

- **长度**：128 位
- **计算方式**：取消息体 SHA-256 哈希的中间 128 位
- **作用**：与 Authorization Key 共同派生 AES 密钥和 IV

### 密钥派生流程

🚧 **待补充**：详细的密钥派生算法图解

---

## 加密算法

MTProto 2.0 使用以下密码学原语：

| 算法               | 用途                             |
| ------------------ | -------------------------------- |
| **AES-256-IGE**    | 消息体加密（256 位密钥）         |
| **RSA-2048**       | 密钥交换、身份验证               |
| **SHA-256**        | 哈希计算（MTProto 1.0 用 SHA-1） |
| **Diffie-Hellman** | 生成 Authorization Key           |

🚧 **待补充**：

- [ ] IGE 模式详解
- [ ] 为什么选择 IGE 而非 CBC/GCM

---

## 消息结构

🚧 **待补充**：消息头和消息体的二进制格式

---

## 云端加密 vs 端到端加密

| 特性           | 云端加密（普通聊天） | 端到端加密（Secret Chat） |
| -------------- | -------------------- | ------------------------- |
| **加密范围**   | 客户端 ↔ 服务器      | 客户端 ↔ 客户端           |
| **服务器可读** | ✅ 理论上可以        | ❌ 无法解密               |
| **多设备同步** | ✅ 支持              | ❌ 仅限发起设备           |
| **消息存储**   | 云端永久存储         | 不存储，阅后可焚          |
| **默认启用**   | ✅ 是                | ❌ 需手动开启             |

---

## 前向保密机制

🚧 **待补充**：MTProto 如何实现 Perfect Forward Secrecy

---

## 与其他协议对比

| 协议                | 使用者           | 开源 | 默认 E2E | 特点           |
| ------------------- | ---------------- | ---- | -------- | -------------- |
| **MTProto**         | Telegram         | ❌   | ❌       | 移动优化，自研 |
| **Signal Protocol** | Signal, WhatsApp | ✅   | ✅       | 业界标准       |
| **Proteus**         | Wire             | ✅   | ✅       | 基于 Signal    |
| **MLS**             | 新标准           | ✅   | ✅       | IETF 标准化中  |

---

## 安全争议与评价

### 正面评价

- 2017 年学术论文证明 MTProto 2.0 满足 IND-CCA 安全性
- 端到端加密通过形式化验证

### 争议与批评

- **自研协议**：未使用 Signal Protocol 等经过更广泛审计的协议
- **非默认 E2E**：普通聊天不启用端到端加密，引发隐私担忧
- **IGE 模式**：部分密码学家认为应使用 AEAD 模式（如 AES-GCM）

---

## 参考资料

### 官方文档

- [MTProto 协议概述](https://core.telegram.org/mtproto)
- [MTProto 详细描述](https://core.telegram.org/mtproto/description)
- [创建 Authorization Key](https://core.telegram.org/mtproto/auth_key)
- [端到端加密（Secret Chats）](https://core.telegram.org/api/end-to-end)
- [TL 语言规范](https://core.telegram.org/mtproto/TL)
- [安全指南](https://core.telegram.org/mtproto/security_guidelines)

### 学术论文

🚧 待补充

---

**最后更新**：2026 年 1 月
