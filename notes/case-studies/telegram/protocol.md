# MTProto 协议深度解析

> 🚧 **撰写中** - 深入分析 Telegram 自研的移动优先加密协议

## 概述

MTProto（Mobile Telegram
Protocol）是 Telegram 自主研发的网络传输协议，由联合创始人 **Nikolai
Durov**（数学天才，三届 IMO 金牌得主）设计。该协议专为移动设备优化，兼顾安全性与性能。

**当前版本**：MTProto 2.0（自 Telegram 4.6 起使用）

**核心设计目标**：

- 🔒 **安全性**：多层加密 + 前向保密
- 🚀 **速度**：弱网环境下依然流畅
- 📱 **移动优先**：针对移动网络特性优化
- 🔄 **可靠性**：自动重连、消息确认机制

---

## 目录

- [协议架构](#协议架构)
- [三层结构详解](#三层结构详解)
  - [高层组件（API 查询语言）](#1-高层组件api-查询语言)
  - [加密层（授权层）](#2-加密层授权层)
  - [传输层](#3-传输层)
- [密钥体系](#密钥体系)
  - [Authorization Key（授权密钥）](#authorization-key授权密钥)
  - [Message Key（消息密钥）](#message-key消息密钥)
  - [密钥派生流程](#密钥派生流程)
- [加密算法](#加密算法)
- [消息结构](#消息结构)
- [云端加密 vs 端到端加密](#云端加密-vs-端到端加密)
- [前向保密机制](#前向保密机制)
- [与其他协议对比](#与其他协议对比)
- [安全争议与评价](#安全争议与评价)
- [参考资料](#参考资料)

---

## 协议架构

MTProto 协议被划分为三个**相对独立**的层次：

```
┌─────────────────────────────────────────────────────┐
│           High-Level Component (API)                │  ← 定义 RPC 调用格式
├─────────────────────────────────────────────────────┤
│        Cryptographic (Authorization) Layer          │  ← 消息加密/解密
├─────────────────────────────────────────────────────┤
│              Transport Component                    │  ← 网络传输（TCP/UDP/WS）
└─────────────────────────────────────────────────────┘
```

这种分层设计使得每一层可以独立升级和优化。

---

## 三层结构详解

### 1. 高层组件（API 查询语言）

**职责**：定义客户端与服务器之间的消息格式和 RPC 调用方式。

**核心概念**：

| 概念                  | 说明                                              |
| --------------------- | ------------------------------------------------- |
| **Session（会话）**   | 绑定到设备/应用，而非单一连接。多个连接可共享会话 |
| **Message ID**        | 64 位消息标识符，用于去重和排序                   |
| **Sequence Number**   | 32 位序列号，确保消息顺序                         |
| **Container（容器）** | 可将多条消息打包成一个容器，减少网络开销          |

**消息类型**：

- RPC 调用（客户端 → 服务器）
- RPC 响应（服务器 → 客户端）
- 消息确认（ACK）
- 消息状态查询
- 容器消息（多条消息打包）

**数据序列化**：

- 使用 **TL（Type Language）** 描述数据结构
- 所有数字采用**小端序**（Little Endian）
- RSA/DH 大数采用**大端序**（Big Endian）
- 消息体长度必须是 4 字节的倍数

---

### 2. 加密层（授权层）

**职责**：在消息传输前进行加密，确保传输安全。

#### 加密流程详解

每条消息在发送前都会经过以下加密处理：

```
┌──────────────────────────────────────────────────────────────┐
│                     明文消息（Plaintext）                     │
│  ┌─────────┬───────────┬──────────┬─────────┬─────────────┐  │
│  │ salt    │ session_id│ msg_id   │ seq_no  │ message_data│  │
│  │ (64-bit)│ (64-bit)  │ (64-bit) │ (32-bit)│ (变长)      │  │
│  └─────────┴───────────┴──────────┴─────────┴─────────────┘  │
└──────────────────────────────────────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  添加 12-1024 字节随机填充   │
              │  (长度需被 16 整除)          │
              └─────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  计算 msg_key (128-bit)     │
              │  = SHA256 中间 128 位        │
              └─────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  派生 aes_key + aes_iv      │
              │  (各 256-bit)               │
              └─────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  AES-256-IGE 加密           │
              └─────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────┐
│                     密文消息（Ciphertext）                    │
│  ┌────────────────┬───────────┬───────────────────────────┐  │
│  │ auth_key_id    │ msg_key   │ encrypted_data            │  │
│  │ (64-bit)       │ (128-bit) │ (变长)                    │  │
│  └────────────────┴───────────┴───────────────────────────┘  │
└──────────────────────────────────────────────────────────────┘
```

#### AES 密钥派生算法（MTProto 2.0）

从 `auth_key`（2048-bit）和 `msg_key`（128-bit）派生实际加密密钥：

```
# x = 0 (客户端→服务器), x = 8 (服务器→客户端)

msg_key_large = SHA256(auth_key[88+x : 88+x+32] + plaintext + padding)
msg_key       = msg_key_large[8 : 24]   # 中间 128 位

sha256_a = SHA256(msg_key + auth_key[x : x+36])
sha256_b = SHA256(auth_key[40+x : 40+x+36] + msg_key)

aes_key = sha256_a[0:8] + sha256_b[8:24] + sha256_a[24:32]   # 256-bit
aes_iv  = sha256_b[0:8] + sha256_a[8:24] + sha256_b[24:32]   # 256-bit
```

**设计亮点**：

- 客户端和服务器使用**不同的 x 偏移**，防止反射攻击
- `auth_key` 的低 1024 位不参与加密，可用于本地数据加密
- 服务器不存储 `auth_key` 的低 512 位，增强用户数据安全

#### 密钥交换过程（创建 Authorization Key）

首次连接时通过 **Diffie-Hellman 密钥交换** 生成 2048-bit 的 `auth_key`：

```
客户端                                   服务器
   │                                       │
   │ ① 请求: req_pq_multi(nonce)           │
   │ ─────────────────────────────────────→│
   │                                       │
   │ ② 响应: pq + server_nonce + 指纹列表   │
   │←───────────────────────────────────── │
   │                                       │
   │ ③ 分解 pq = p × q (素数分解)          │
   │                                       │
   │ ④ 发送: p, q, new_nonce (RSA 加密)    │
   │ ─────────────────────────────────────→│
   │                                       │
   │ ⑤ 响应: DH 参数 (g, p, g_a)           │
   │←───────────────────────────────────── │
   │                                       │
   │ ⑥ 计算 g_b, 发送给服务器              │
   │ ─────────────────────────────────────→│
   │                                       │
   │ ⑦ 双方计算: auth_key = g_ab mod p     │
   │                                       │
   └───────────────────────────────────────┘
```

**关键安全设计**：

- **素数分解挑战**：客户端需分解 `pq`，证明不是简单的重放攻击
- **RSA-OAEP+ 加密**：`new_nonce` 通过 RSA 加密传输，防止中间人
- **临时密钥支持**：可生成有时效的临时密钥，实现前向保密（PFS）

#### Server Salt 机制

**Server Salt** 是一个 64-bit 随机值，用于防止重放攻击：

| 属性         | 说明                                                           |
| ------------ | -------------------------------------------------------------- |
| **长度**     | 64 位                                                          |
| **生命周期** | 由服务器决定，通常 30 分钟到 24 小时                           |
| **更新方式** | 服务器通过 `new_session_created` 或 `bad_server_salt` 消息通知 |
| **作用**     | 与 `session_id` 一起防止跨会话重放                             |

**工作原理**：

1. 每条消息的明文头部都包含当前 `server_salt`
2. 服务器验证 `salt` 是否在有效范围内
3. 如果 `salt` 过期，服务器返回 `bad_server_salt` 错误并提供新值
4. 客户端更新本地 `salt` 并重发消息

**代码示例**（概念性）：

```python
# 消息明文结构
plaintext = struct.pack('<q', server_salt)      # 64-bit salt
         + struct.pack('<q', session_id)        # 64-bit session
         + struct.pack('<q', msg_id)            # 64-bit message ID
         + struct.pack('<i', seq_no)            # 32-bit sequence
         + struct.pack('<i', len(message_data)) # 32-bit length
         + message_data                         # 消息内容
         + random_padding                       # 12-1024 字节填充
```

#### 解密时的安全检查

接收消息后必须验证：

1. **msg_key 验证**：解密后重新计算 `msg_key`，与收到的值比对
2. **msg_id 奇偶性**：客户端→服务器必须为偶数，反之为奇数
3. **msg_id 时间窗口**：不接受超过 30 秒后或 300 秒前的消息
4. **msg_id 去重**：保留最近 N 条消息 ID，拒绝重复

---

### 3. 传输层

**职责**：将加密后的消息通过网络传输。

#### 支持的传输协议

| 协议           | 特点               | 使用场景      |
| -------------- | ------------------ | ------------- |
| **TCP**        | 稳定可靠，主流方式 | 大多数客户端  |
| **UDP**        | 低延迟             | 语音/视频通话 |
| **HTTP/HTTPS** | 穿透防火墙         | 受限网络环境  |
| **WebSocket**  | 全双工，浏览器友好 | Web 客户端    |

#### TCP 包格式（4 种变体）

MTProto 在 TCP 层定义了 4 种不同的封装格式，适用于不同场景：

**1. Abridged（精简模式）**

最轻量的协议，开销仅 1-4 字节。

```
首次连接: 发送 0xef 作为握手字节

短消息 (长度/4 < 127):
+---------+-------------+
| len (1B)| payload     |
+---------+-------------+

长消息 (长度/4 >= 127):
+------+----------+-------------+
| 0x7f | len (3B) | payload     |
+------+----------+-------------+
```

- `len` = payload 长度 ÷ 4（必须是 4 的倍数）

**2. Intermediate（中间模式）**

4 字节对齐，适合需要对齐的场景。

```
首次连接: 发送 0xeeeeeeee (4 字节)

+----------+-------------+
| len (4B) | payload     |
+----------+-------------+
```

**3. Padded Intermediate（填充中间模式）**

带随机填充，用于绕过 ISP 封锁。

```
首次连接: 发送 0xdddddddd (4 字节)

+----------+-------------+---------------+
| tlen (4B)| payload     | padding (0-15)|
+----------+-------------+---------------+
```

- `tlen` = payload + padding 的总长度

**4. Full（完整模式）**

包含序列号和 CRC 校验，最可靠但开销最大。

```
+----------+----------+-------------+----------+
| len (4B) | seq (4B) | payload     | crc (4B) |
+----------+----------+-------------+----------+
```

- `len` = 整个包的长度（包括 len 自身）
- `seq` = TCP 层序列号（从 0 开始递增）
- `crc` = CRC32 校验（覆盖 len + seq + payload）

#### 协议选择建议

| 场景                 | 推荐协议                   | 理由               |
| -------------------- | -------------------------- | ------------------ |
| 普通移动网络         | Abridged                   | 最小开销，省流量   |
| 需要对齐的嵌入式设备 | Intermediate               | 4 字节对齐简化解析 |
| 受审查网络           | Padded Intermediate + 混淆 | 随机填充难以识别   |
| 调试/低质量网络      | Full                       | CRC 校验保证完整性 |

#### Quick ACK 机制

客户端可请求服务器快速确认收到消息：

1. 发送时在 `len` 字段设置最高位（`len | 0x80000000`）
2. 服务器收到并解密成功后，立即返回 4 字节 ACK token
3. ACK token = `SHA256(auth_key[0:32] + encrypted_data)[0:4] | 0x80000000`

> **注意**：Quick ACK 仅表示消息已收到并进入处理队列，不代表 RPC 调用已完成。

#### 传输错误码

服务器可能返回以下传输层错误（4 字节有符号整数，负值）：

| 错误码   | 含义                       |
| -------- | -------------------------- |
| **-403** | 权限错误（类似 HTTP 403）  |
| **-404** | Auth Key 未找到            |
| **-429** | 传输层限流（连接过于频繁） |
| **-444** | 无效的 DC ID               |

#### 传输层混淆（Transport Obfuscation）

为绕过深度包检测（DPI）和 ISP 封锁，MTProto 支持**传输层混淆**：

1. 生成 64 字节随机密钥（避免与已知协议头冲突）
2. 使用 AES-256-CTR 加密整个 TCP 流
3. 密钥派生自随机数据，对外表现为完全随机流量

> **WebSocket 传输必须启用混淆**

#### 负载均衡与连接复用

**多数据中心架构**：

```
┌─────────────────────────────────────────────────────────────┐
│                        Telegram 全球数据中心                 │
├───────────┬───────────┬───────────┬───────────┬────────────┤
│  DC1      │  DC2      │  DC3      │  DC4      │  DC5       │
│ 美国东部   │ 荷兰      │ 美国西部   │ 新加坡    │ 新加坡     │
│ (主用户DC) │ (欧洲)    │ (媒体)    │ (亚洲)    │ (媒体)     │
└───────────┴───────────┴───────────┴───────────┴────────────┘
```

**连接复用策略**：

| 特性                   | 说明                                         |
| ---------------------- | -------------------------------------------- |
| **Session 独立于连接** | 一个 Session 可跨多个 TCP 连接               |
| **多连接并行**         | 客户端可同时建立多个 TCP 连接到同一 DC       |
| **响应路由灵活**       | RPC 响应可通过任意同 Session 的连接返回      |
| **DC 迁移**            | 用户可被分配到不同 DC，auth_key 可跨 DC 绑定 |

**自动 DC 选择**：

1. 客户端首次连接时获取最近 DC 列表
2. 根据延迟和负载选择最优 DC
3. 媒体文件可从专用媒体 DC 下载（并行加速）

---

## 密钥体系

### Authorization Key（授权密钥）

- **长度**：2048 位
- **生成方式**：Diffie-Hellman 密钥交换
- **生命周期**：设备首次连接时生成，几乎永不更换
- **存储**：仅存储于客户端和服务器，**从不在网络上传输**

### Message Key（消息密钥）

- **长度**：128 位
- **计算方式**：取消息体 SHA-256 哈希的中间 128 位
- **作用**：与 Authorization Key 共同派生 AES 密钥和 IV

### 密钥派生流程

🚧 **待补充**：详细的密钥派生算法图解

---

## 加密算法

MTProto 2.0 使用以下密码学原语：

| 算法               | 用途                             |
| ------------------ | -------------------------------- |
| **AES-256-IGE**    | 消息体加密（256 位密钥）         |
| **RSA-2048**       | 密钥交换、身份验证               |
| **SHA-256**        | 哈希计算（MTProto 1.0 用 SHA-1） |
| **Diffie-Hellman** | 生成 Authorization Key           |

🚧 **待补充**：

- [ ] IGE 模式详解
- [ ] 为什么选择 IGE 而非 CBC/GCM

---

## 消息结构

🚧 **待补充**：消息头和消息体的二进制格式

---

## 云端加密 vs 端到端加密

| 特性           | 云端加密（普通聊天） | 端到端加密（Secret Chat） |
| -------------- | -------------------- | ------------------------- |
| **加密范围**   | 客户端 ↔ 服务器      | 客户端 ↔ 客户端           |
| **服务器可读** | ✅ 理论上可以        | ❌ 无法解密               |
| **多设备同步** | ✅ 支持              | ❌ 仅限发起设备           |
| **消息存储**   | 云端永久存储         | 不存储，阅后可焚          |
| **默认启用**   | ✅ 是                | ❌ 需手动开启             |

---

## 前向保密机制

🚧 **待补充**：MTProto 如何实现 Perfect Forward Secrecy

---

## 与其他协议对比

| 协议                | 使用者           | 开源 | 默认 E2E | 特点           |
| ------------------- | ---------------- | ---- | -------- | -------------- |
| **MTProto**         | Telegram         | ❌   | ❌       | 移动优化，自研 |
| **Signal Protocol** | Signal, WhatsApp | ✅   | ✅       | 业界标准       |
| **Proteus**         | Wire             | ✅   | ✅       | 基于 Signal    |
| **MLS**             | 新标准           | ✅   | ✅       | IETF 标准化中  |

---

## 安全争议与评价

### 正面评价

- 2017 年学术论文证明 MTProto 2.0 满足 IND-CCA 安全性
- 端到端加密通过形式化验证

### 争议与批评

- **自研协议**：未使用 Signal Protocol 等经过更广泛审计的协议
- **非默认 E2E**：普通聊天不启用端到端加密，引发隐私担忧
- **IGE 模式**：部分密码学家认为应使用 AEAD 模式（如 AES-GCM）

---

## 参考资料

### 官方文档

- [MTProto 协议概述](https://core.telegram.org/mtproto)
- [MTProto 详细描述](https://core.telegram.org/mtproto/description)
- [创建 Authorization Key](https://core.telegram.org/mtproto/auth_key)
- [端到端加密（Secret Chats）](https://core.telegram.org/api/end-to-end)
- [TL 语言规范](https://core.telegram.org/mtproto/TL)
- [安全指南](https://core.telegram.org/mtproto/security_guidelines)

### 学术论文

🚧 待补充

---

**最后更新**：2026 年 1 月
