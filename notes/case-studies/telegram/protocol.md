# MTProto 协议深度解析

> 深入分析 Telegram 自研的移动优先加密协议

## 简介：给新手的 MTProto 入门

### 什么是 MTProto？

想象你在和朋友发微信，消息是这样传递的：

```text
你的手机 → 微信服务器 → 朋友的手机
```

**MTProto 就是 Telegram 版本的'消息传递规则'**，它规定了：

- 消息怎么打包（像快递打包）
- 怎么加密（像给快递加锁）
- 怎么传输（选顺丰还是京东）

### 为什么 Telegram 不用现成的协议？

- 现有协议：HTTPS；问题：太重，不适合移动网络频繁断开/重连
- 现有协议：Signal Protocol；问题：2013 年还没普及，且只管加密不管传输

所以 Telegram 的数学天才 Nikolai Durov **自己发明了一套**，专门针对：

- 📶 弱网环境（地铁、电梯）
- 🔋 省电省流量
- ⚡ 快速重连

### 核心概念速览

**记住这 3 个关键词就够了**：

- 概念：**Authorization Key**；类比：你家的门锁钥匙；作用：证明'我是我'，几乎永不更换
- 概念：**Message Key**；类比：每封信的密封贴纸；作用：每条消息不同，防篡改
- 概念：**Session**；类比：一次对话会话；作用：支持多设备、断线重连

### 阅读建议

- 你的背景：**产品/运营**；推荐阅读顺序：简介 → 云端 vs 端到端加密 → 安全争议
- 你的背景：**前端开发**；推荐阅读顺序：简介 → 传输层 → 消息结构
- 你的背景：**后端/安全**；推荐阅读顺序：全部按顺序阅读
- 你的背景：**密码学爱好者**；推荐阅读顺序：直接跳到加密算法 → IGE 模式

---

## 概述

MTProto（Mobile Telegram Protocol）是 Telegram 自主研发的网络传输协议，由联合创始人 **Nikolai
Durov**（数学天才，三届 IMO 金牌得主）设计。该协议专为移动设备优化，兼顾安全性与性能。

**当前版本**：MTProto 2.0（自 Telegram 4.6 起使用）

**核心设计目标**：

- 🔒 **安全性**：多层加密 + 前向保密
- 🚀 **速度**：弱网环境下依然流畅
- 📱 **移动优先**：针对移动网络特性优化
- 🔄 **可靠性**：自动重连、消息确认机制

**协议公开状态**：

- 组件：**协议规范**；状态：✅ 公开；说明：任何人可阅读并实现自己的客户端
- 组件：**官方客户端**；状态：✅ 开源；说明：iOS/Android/Desktop 均在 GitHub
- 组件：**TDLib 核心库**；状态：✅ 开源；说明：github.com/tdlib/td
  <https://github.com/tdlib/td>
- 组件：**服务端代码**；状态：❌ 闭源；说明：从未公开

> **信息来源**：本文内容主要来自
> Telegram 官方 MTProto 文档，包括协议描述、密钥创建、传输协议等子页面。
> <https://core.telegram.org/mtproto>

---

## 目录

- [1. 协议架构](#1-协议架构)
- [2. 三层结构详解](#2-三层结构详解)
  - [2.1 高层组件（API 查询语言）](#21-高层组件api-查询语言)
  - [2.2 加密层（授权层）](#22-加密层授权层)
  - [2.3 传输层](#23-传输层)
- [3. 密钥体系](#3-密钥体系)
  - [3.1 Authorization Key](#31-authorization-key)
  - [3.2 Message Key](#32-message-key)
  - [3.3 密钥派生流程](#33-密钥派生流程)
- [4. 加密算法](#4-加密算法)
- [5. 消息结构](#5-消息结构)
- [6. 云端加密 vs 端到端加密](#6-云端加密-vs-端到端加密)
- [7. 前向保密机制](#7-前向保密机制)
- [8. 与其他协议对比](#8-与其他协议对比)
- [9. 安全争议与评价](#9-安全争议与评价)
- [参考资料](#参考资料)

---

## 1. 协议架构

MTProto 协议被划分为三个**相对独立**的层次：

```text
┌─────────────────────────────────────────────────────┐
│           High-Level Component (API)                │  ← 定义 RPC 调用格式
├─────────────────────────────────────────────────────┤
│        Cryptographic (Authorization) Layer          │  ← 消息加密/解密
├─────────────────────────────────────────────────────┤
│              Transport Component                    │  ← 网络传输（TCP/UDP/WS）
└─────────────────────────────────────────────────────┘
```

这种分层设计使得每一层可以独立升级和优化。

---

## 2. 三层结构详解

### 2.1 高层组件（API 查询语言）

**职责**：定义客户端与服务器之间的消息格式和 RPC 调用方式。

**核心概念**：

- 概念：**Session（会话）**；说明：绑定到设备/应用，而非单一连接。多个连接可共享会话
- 概念：**Message ID**；说明：64 位消息标识符，用于去重和排序
- 概念：**Sequence Number**；说明：32 位序列号，确保消息顺序
- 概念：**Container（容器）**；说明：可将多条消息打包成一个容器，减少网络开销

**消息类型**：

- RPC 调用（客户端 → 服务器）
- RPC 响应（服务器 → 客户端）
- 消息确认（ACK）
- 消息状态查询
- 容器消息（多条消息打包）

**数据序列化**：

- 使用 **TL（Type Language）** 描述数据结构
- 所有数字采用**小端序**（Little Endian）
- RSA/DH 大数采用**大端序**（Big Endian）
- 消息体长度必须是 4 字节的倍数

---

### 2.2 加密层（授权层）

**职责**：在消息传输前进行加密，确保传输安全。

#### 加密流程详解

每条消息在发送前都会经过以下加密处理：

```text
┌──────────────────────────────────────────────────────────────┐
│                     明文消息（Plaintext）                     │
│  ┌─────────┬───────────┬──────────┬─────────┬─────────────┐  │
│  │ salt    │ session_id│ msg_id   │ seq_no  │ message_data│  │
│  │ (64-bit)│ (64-bit)  │ (64-bit) │ (32-bit)│ (变长)      │  │
│  └─────────┴───────────┴──────────┴─────────┴─────────────┘  │
└──────────────────────────────────────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  添加 12-1024 字节随机填充   │
              │  (长度需被 16 整除)          │
              └─────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  计算 msg_key (128-bit)     │
              │  = SHA256 中间 128 位        │
              └─────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  派生 aes_key + aes_iv      │
              │  (各 256-bit)               │
              └─────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │  AES-256-IGE 加密           │
              └─────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────┐
│                     密文消息（Ciphertext）                    │
│  ┌────────────────┬───────────┬───────────────────────────┐  │
│  │ auth_key_id    │ msg_key   │ encrypted_data            │  │
│  │ (64-bit)       │ (128-bit) │ (变长)                    │  │
│  └────────────────┴───────────┴───────────────────────────┘  │
└──────────────────────────────────────────────────────────────┘
```

#### AES 密钥派生算法（MTProto 2.0）

从 `auth_key`（2048-bit）和 `msg_key`（128-bit）派生实际加密密钥：

```text
# x = 0 (客户端→服务器), x = 8 (服务器→客户端)

msg_key_large = SHA256(auth_key[88+x : 88+x+32] + plaintext + padding)
msg_key       = msg_key_large[8 : 24]   # 中间 128 位

sha256_a = SHA256(msg_key + auth_key[x : x+36])
sha256_b = SHA256(auth_key[40+x : 40+x+36] + msg_key)

aes_key = sha256_a[0:8] + sha256_b[8:24] + sha256_a[24:32]   # 256-bit
aes_iv  = sha256_b[0:8] + sha256_a[8:24] + sha256_b[24:32]   # 256-bit
```

**设计亮点**：

- 客户端和服务器使用**不同的 x 偏移**，防止反射攻击
- `auth_key` 的低 1024 位不参与加密，可用于本地数据加密
- 服务器不存储 `auth_key` 的低 512 位，增强用户数据安全

#### 密钥交换过程（创建 Authorization Key）

首次连接时通过 **Diffie-Hellman 密钥交换** 生成 2048-bit 的 `auth_key`：

```text
客户端                                   服务器
   │                                       │
   │ ① 请求: req_pq_multi(nonce)           │
   │ ─────────────────────────────────────→│
   │                                       │
   │ ② 响应: pq + server_nonce + 指纹列表   │
   │←───────────────────────────────────── │
   │                                       │
   │ ③ 分解 pq = p × q (素数分解)          │
   │                                       │
   │ ④ 发送: p, q, new_nonce (RSA 加密)    │
   │ ─────────────────────────────────────→│
   │                                       │
   │ ⑤ 响应: DH 参数 (g, p, g_a)           │
   │←───────────────────────────────────── │
   │                                       │
   │ ⑥ 计算 g_b, 发送给服务器              │
   │ ─────────────────────────────────────→│
   │                                       │
   │ ⑦ 双方计算: auth_key = g_ab mod p     │
   │                                       │
   └───────────────────────────────────────┘
```

**关键安全设计**：

- **素数分解挑战**：客户端需分解 `pq`，证明不是简单的重放攻击
- **RSA-OAEP+ 加密**：`new_nonce` 通过 RSA 加密传输，防止中间人
- **临时密钥支持**：可生成有时效的临时密钥，实现前向保密（PFS）

#### Server Salt 机制

**Server Salt** 是一个 64-bit 随机值，用于防止重放攻击：

- 属性：**长度**；说明：64 位
- 属性：**生命周期**；说明：由服务器决定，通常 30 分钟到 24 小时
- 属性：**更新方式**；说明：服务器通过 `new_session_created` 或 `bad_server_salt` 消息通知
- 属性：**作用**；说明：与 `session_id` 一起防止跨会话重放

**工作原理**：

1. 每条消息的明文头部都包含当前 `server_salt` 2. 服务器验证 `salt` 是否在有效范围内 3. 如果 `salt` 过期，服务器返回
`bad_server_salt` 错误并提供新值 4. 客户端更新本地 `salt` 并重发消息

**代码示例**（概念性）：

```python
# 消息明文结构
plaintext = struct.pack('<q', server_salt)      # 64-bit salt
         + struct.pack('<q', session_id)        # 64-bit session
         + struct.pack('<q', msg_id)            # 64-bit message ID
         + struct.pack('<i', seq_no)            # 32-bit sequence
         + struct.pack('<i', len(message_data)) # 32-bit length
         + message_data                         # 消息内容
         + random_padding                       # 12-1024 字节填充
```

#### 解密时的安全检查

接收消息后必须验证：

1. **msg_key 验证**：解密后重新计算 `msg_key`，与收到的值比对 2. **msg_id 奇偶性**：客户端→服务器必须为偶数，反之为奇数
3. **msg_id 时间窗口**：不接受超过 30 秒后或 300 秒前的消息 4. **msg_id 去重**：保留最近 N 条消息 ID，拒绝重复

---

### 2.3 传输层

**职责**：将加密后的消息通过网络传输。

#### 支持的传输协议

- 协议：**TCP**；特点：稳定可靠，主流方式；使用场景：大多数客户端
- 协议：**UDP**；特点：低延迟；使用场景：语音/视频通话
- 协议：**HTTP/HTTPS**；特点：穿透防火墙；使用场景：受限网络环境
- 协议：**WebSocket**；特点：全双工，浏览器友好；使用场景：Web 客户端

#### TCP 包格式（4 种变体）

MTProto 在 TCP 层定义了 4 种不同的封装格式，适用于不同场景：

**1. Abridged（精简模式）**

最轻量的协议，开销仅 1-4 字节。

```text
首次连接: 发送 0xef 作为握手字节

短消息 (长度/4 < 127):
+---------+-------------+
| len (1B)| payload     |
+---------+-------------+

长消息 (长度/4 >= 127):
+------+----------+-------------+
| 0x7f | len (3B) | payload     |
+------+----------+-------------+
```

- `len` = payload 长度 ÷ 4（必须是 4 的倍数）

**2. Intermediate（中间模式）**

4 字节对齐，适合需要对齐的场景。

```text
首次连接: 发送 0xeeeeeeee (4 字节)

+----------+-------------+
| len (4B) | payload     |
+----------+-------------+
```

**3. Padded Intermediate（填充中间模式）**

带随机填充，用于绕过 ISP 封锁。

```text
首次连接: 发送 0xdddddddd (4 字节)

+----------+-------------+---------------+
| tlen (4B)| payload     | padding (0-15)|
+----------+-------------+---------------+
```

- `tlen` = payload + padding 的总长度

**4. Full（完整模式）**

包含序列号和 CRC 校验，最可靠但开销最大。

```text
+----------+----------+-------------+----------+
| len (4B) | seq (4B) | payload     | crc (4B) |
+----------+----------+-------------+----------+
```

- `len` = 整个包的长度（包括 len 自身）
- `seq` = TCP 层序列号（从 0 开始递增）
- `crc` = CRC32 校验（覆盖 len + seq + payload）

#### 协议选择建议

- 场景：普通移动网络；推荐协议：Abridged；理由：最小开销，省流量
- 场景：需要对齐的嵌入式设备；推荐协议：Intermediate；理由：4 字节对齐简化解析
- 场景：受审查网络；推荐协议：Padded Intermediate + 混淆；理由：随机填充难以识别
- 场景：调试/低质量网络；推荐协议：Full；理由：CRC 校验保证完整性

#### Quick ACK 机制

客户端可请求服务器快速确认收到消息：

1. 发送时在 `len` 字段设置最高位（`len | 0x80000000`） 2. 服务器收到并解密成功后，立即返回 4 字节 ACK token 3.
ACK token = `SHA256(auth_key[0:32] + encrypted_data)[0:4] | 0x80000000`

> **注意**：Quick ACK 仅表示消息已收到并进入处理队列，不代表 RPC 调用已完成。

#### 传输错误码

服务器可能返回以下传输层错误（4 字节有符号整数，负值）：

- 错误码：**-403**；含义：权限错误（类似 HTTP 403）
- 错误码：**-404**；含义：Auth Key 未找到
- 错误码：**-429**；含义：传输层限流（连接过于频繁）
- 错误码：**-444**；含义：无效的 DC ID

#### 传输层混淆（Transport Obfuscation）

为绕过深度包检测（DPI）和 ISP 封锁，MTProto 支持**传输层混淆**：

1. 生成 64 字节随机密钥（避免与已知协议头冲突） 2. 使用 AES-256-CTR 加密整个 TCP 流 3.
密钥派生自随机数据，对外表现为完全随机流量

> **WebSocket 传输必须启用混淆**

#### 负载均衡与连接复用

**多数据中心架构**：

```text
┌─────────────────────────────────────────────────────────────┐
│                        Telegram 全球数据中心                 │
├───────────┬───────────┬───────────┬───────────┬────────────┤
│  DC1      │  DC2      │  DC3      │  DC4      │  DC5       │
│ 美国东部   │ 荷兰      │ 美国西部   │ 新加坡    │ 新加坡     │
│ (主用户DC) │ (欧洲)    │ (媒体)    │ (亚洲)    │ (媒体)     │
└───────────┴───────────┴───────────┴───────────┴────────────┘
```

**连接复用策略**：

- 特性：**Session 独立于连接**；说明：一个 Session 可跨多个 TCP 连接
- 特性：**多连接并行**；说明：客户端可同时建立多个 TCP 连接到同一 DC
- 特性：**响应路由灵活**；说明：RPC 响应可通过任意同 Session 的连接返回
- 特性：**DC 迁移**；说明：用户可被分配到不同 DC，auth_key 可跨 DC 绑定

**自动 DC 选择**：

1. 客户端首次连接时获取最近 DC 列表 2. 根据延迟和负载选择最优 DC 3. 媒体文件可从专用媒体 DC 下载（并行加速）

---

## 3. 密钥体系

### 3.1 Authorization Key（授权密钥）

- **长度**：2048 位
- **生成方式**：Diffie-Hellman 密钥交换
- **生命周期**：设备首次连接时生成，几乎永不更换
- **存储**：仅存储于客户端和服务器，**从不在网络上传输**

### 3.2 Message Key（消息密钥）

- **长度**：128 位
- **计算方式**：取消息体 SHA-256 哈希的中间 128 位
- **作用**：与 Authorization Key 共同派生 AES 密钥和 IV

### 3.3 密钥派生流程

从 `auth_key` 和 `msg_key` 派生 AES 加密所需的密钥和 IV：

```text
                    auth_key (2048-bit)
                           │
          ┌────────────────┼────────────────┐
          │                │                │
   [88+x : 88+x+32]   [x : x+36]    [40+x : 40+x+36]
          │                │                │
          ▼                │                │
    ┌──────────┐           │                │
    │ SHA-256  │◀── plaintext + padding     │
    └──────────┘           │                │
          │                │                │
          ▼                │                │
    msg_key_large          │                │
    [8:24] = msg_key       │                │
          │                │                │
          │    ┌───────────┘                │
          ▼    ▼                            ▼
    ┌──────────────┐                 ┌──────────────┐
    │   SHA-256    │                 │   SHA-256    │
    │ msg_key +    │                 │ auth_key +   │
    │ auth_key[x]  │                 │ msg_key      │
    └──────────────┘                 └──────────────┘
          │                                 │
          ▼                                 ▼
      sha256_a                          sha256_b
          │                                 │
          └──────────┬──────────────────────┘
                     │
                     ▼
    ┌────────────────────────────────────────────┐
    │  aes_key = a[0:8] + b[8:24] + a[24:32]     │
    │  aes_iv  = b[0:8] + a[8:24] + b[24:32]     │
    └────────────────────────────────────────────┘
```

**注**：`x = 0` 表示客户端→服务器，`x = 8` 表示服务器→客户端

---

## 4. 加密算法

MTProto 2.0 使用以下密码学原语：

- 算法：**AES-256-IGE**；用途：消息体加密（256 位密钥）
- 算法：**RSA-2048**；用途：密钥交换、身份验证
- 算法：**SHA-256**；用途：哈希计算（MTProto 1.0 用 SHA-1）
- 算法：**Diffie-Hellman**；用途：生成 Authorization Key

#### IGE（Infinite Garble Extension）模式详解

**工作原理**：

```text
加密过程：
C[0] = E(P[0] XOR IV1) XOR IV2
C[i] = E(P[i] XOR C[i-1]) XOR P[i-1]   (i > 0)

解密过程：
P[0] = D(C[0] XOR IV2) XOR IV1
P[i] = D(C[i] XOR P[i-1]) XOR C[i-1]   (i > 0)
```

**IGE 的特点**：

- 特性：**错误传播**；说明：一个密文块错误会影响后续所有明文块（'无限扩散'）
- 特性：**无并行化**；说明：加密/解密必须串行，无法利用多核
- 特性：**无内置认证**；说明：不提供完整性校验，需额外 MAC

#### 为什么 MTProto 选择 IGE 而非 GCM？

- 对比项：**认证方式**；IGE (MTProto)：解密后校验 SHA-256；GCM (业界主流)：加密时生成 GMAC
- 对比项：**错误检测**；IGE (MTProto)：解密后才知道；GCM (业界主流)：可提前拒绝无效密文
- 对比项：**性能**；IGE (MTProto)：串行，无硬件加速；GCM (业界主流)：并行，AES-NI 加速
- 对比项：**Nonce 敏感性**；IGE (MTProto)：不依赖 Nonce；GCM (业界主流)：Nonce 重用导致灾难
- 对比项：**标准化**；IGE (MTProto)：非标准；GCM (业界主流)：TLS 1.3、IPsec 采用

**Telegram 的辩护**：

1. **消息内容绑定密钥**：`msg_key` 依赖于明文内容，使得自适应攻击无法进行 2. **解密后全面校验**：验证
salt、session_id、msg_id、长度、时间戳 3. **历史原因**：MTProto 设计于 2013 年，当时 GCM 尚未普及

**批评观点**：

- IGE 是'失败的认证加密尝试'，不如 GCM 成熟
- 先解密后校验意味着用密钥处理不可信数据
- 建议迁移到 AES-GCM 或 ChaCha20-Poly1305

---

## 5. 消息结构

### 加密前的明文结构

```text
+------------+------------+------------+----------+----------+-----------+
| server_salt| session_id | msg_id     | seq_no   | msg_len  | msg_data  |
| (8 bytes)  | (8 bytes)  | (8 bytes)  | (4 bytes)| (4 bytes)| (变长)    |
+------------+------------+------------+----------+----------+-----------+
|<-------------------------- 需被 16 整除 -------------------------->|
|                       + random_padding (12-1024 bytes)              |
```

### 各字段说明

- 字段：**server_salt**；长度：64-bit；说明：防重放，由服务器分配
- 字段：**session_id**；长度：64-bit；说明：客户端生成，标识会话
- 字段：**msg_id**；长度：64-bit；说明：时间戳×2^32 + 序号，必须递增
- 字段：**seq_no**；长度：32-bit；说明：内容相关消息计数器×2 + 1（或×2）
- 字段：**msg_len**；长度：32-bit；说明：msg_data 的字节长度
- 字段：**msg_data**；长度：变长；说明：TL 序列化的消息内容
- 字段：**padding**；长度：12-1024；说明：随机填充，使总长度被 16 整除

### 加密后的密文结构

```text
+---------------+-------------+------------------+
| auth_key_id   | msg_key     | encrypted_data   |
| (8 bytes)     | (16 bytes)  | (变长)           |
+---------------+-------------+------------------+
```

- **auth_key_id**：`SHA1(auth_key)[12:20]`，用于标识使用的授权密钥
- **msg_key**：加密密钥的派生参数
- **encrypted_data**：AES-256-IGE 加密后的数据

---

## 6. 云端加密 vs 端到端加密

- 特性：**加密范围**；云端加密（普通聊天）：客户端 ↔ 服务器；端到端加密（Secret Chat）：客户端 ↔ 客户端
- 特性：**服务器可读**；云端加密（普通聊天）：✅ 理论上可以；端到端加密（Secret Chat）：❌ 无法解密
- 特性：**多设备同步**；云端加密（普通聊天）：✅ 支持；端到端加密（Secret Chat）：❌ 仅限发起设备
- 特性：**消息存储**；云端加密（普通聊天）：云端永久存储；端到端加密（Secret Chat）：不存储，阅后可焚
- 特性：**默认启用**；云端加密（普通聊天）：✅ 是；端到端加密（Secret Chat）：❌ 需手动开启

---

## 7. 前向保密机制

MTProto 通过**临时密钥**机制实现前向保密（Perfect Forward Secrecy），确保即使长期密钥泄露，历史通信也不可解密。

### 云端聊天的 PFS（客户端-服务器）

```text
┌─────────────────────────────────────────────────────────────────────┐
│                      Permanent Authorization Key                     │
│                      (长期存储，几乎不变)                            │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                │ auth.bindTempAuthKey()
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      Temporary Authorization Key                     │
│                      (RAM 存储，定期过期)                            │
│                                                                      │
│  • 使用 p_q_inner_data_temp 创建                                     │
│  • expires_in 参数控制有效期                                         │
│  • 过期后重新生成并绑定                                              │
└─────────────────────────────────────────────────────────────────────┘
```

**工作流程**：

1. 客户端创建临时 `auth_key`（设置 `expires_in`） 2. 使用 `auth.bindTempAuthKey` 将临时密钥绑定到永久密钥
3. 所有消息使用临时密钥加密 4. 临时密钥过期后，重新生成并绑定 5. 旧的临时密钥从服务器 RAM 中删除

### Secret Chat 的 PFS（端到端）

Secret Chat 使用更激进的密钥更新策略：

- 触发条件：加密/解密超过 **100 条消息**；操作：自动发起 Re-keying
- 触发条件：密钥使用超过 **1 周**；操作：自动发起 Re-keying
- 触发条件：任意一方主动请求；操作：协商新密钥

**Re-keying 流程**：

```text
Alice                                   Bob
  │                                      │
  │ ① 生成新的 DH 参数 (a', g^a')        │
  │ ─────────────────────────────────────→
  │                                      │
  │ ② 生成 b', 计算 new_key = (g^a')^b'  │
  │←───────────────────────────────────── │
  │                                      │
  │ ③ 双方切换到 new_key                 │
  │    销毁 old_key（不可恢复）          │
  └──────────────────────────────────────┘
```

**安全保证**：即使攻击者获得当前密钥，也无法解密历史消息，因为旧密钥已被安全销毁。

---

## 8. 与其他协议对比

### 主流通讯应用加密技术一览

- 应用：**Telegram**；加密协议：MTProto 2.0；默认 E2E：❌ 仅 Secret Chat；服务器可读：✅
普通聊天可读；开源：规范公开；量子安全：❌；特点：移动优化，自研
- 应用：**WhatsApp**；加密协议：Signal Protocol；默认 E2E：✅；服务器可读：❌ 无法读取；开源：❌
闭源实现；量子安全：❌；特点：业界标准，Meta 旗下
- 应用：**Signal**；加密协议：Signal Protocol；默认 E2E：✅；服务器可读：❌ 无法读取；开源：✅ 完全开源；量子安全：✅
PQXDH；特点：隐私标杆，非营利
- 应用：**iMessage**；加密协议：PQ3；默认 E2E：✅ 仅 Apple 设备；服务器可读：❌ 无法读取；开源：❌；量子安全：✅
Kyber；特点：量子安全等级最高
- 应用：**微信**；加密协议：MMTLS (魔改 TLS)；默认 E2E：❌；服务器可读：✅ 完全可读；开源：❌；量子安全：❌；特点：服务器可读，无前向保密
- 应用：**Line**；加密协议：Letter Sealing；默认 E2E：✅ 可选；服务器可读：⚠️
未开启时可读；开源：❌；量子安全：❌；特点：日本/东南亚流行
- 应用：**Discord**；加密协议：TLS 1.3；默认 E2E：❌；服务器可读：✅ 完全可读；开源：❌；量子安全：❌；特点：仅传输加密，服务器可读

### 各协议详解

#### Signal Protocol（WhatsApp / Signal / Facebook Messenger）

**业界黄金标准**，被 WhatsApp、Facebook Messenger（Secret Conversations）等采用。

- 特性：**双棘轮算法**；说明：每条消息一个密钥，前向保密 + 后向安全
- 特性：**X3DH**；说明：异步密钥交换，支持离线消息
- 特性：**Curve25519**；说明：椭圆曲线加密
- 特性：**开源**；说明：完全公开，经大量审计
- 特性：**量子安全**；说明：2024 年推出 PQXDH + SPQR（三重棘轮）

**优势**：经过学术验证，广泛采用，不断进化 **劣势**：WhatsApp 闭源实现，备份默认不加密

#### PQ3 Protocol（iMessage）

Apple 于 2024 年 2 月推出的**量子安全协议**。

- 特性：**安全等级**；说明：Level 3（最高），超越 Signal
- 特性：**抗量子算法**；说明：NIST 批准的 Kyber 算法
- 特性：**密钥轮换**；说明：每 50 条消息或 7 天轮换一次
- 特性：**限制**；说明：仅 Apple 设备间有效，与 Android 通信退化为 SMS

**优势**：业界首个 Level 3 量子安全协议 **劣势**：仅限 Apple 生态，闭源

#### MMTLS（微信）

腾讯自研的**魔改 TLS 1.3** + 业务层加密。

- 特性：**端到端加密**；说明：❌ 服务器可解密所有消息
- 特性：**前向保密**；说明：❌ 缺失
- 特性：**初始化向量**；说明：使用确定性 IV（违反密码学最佳实践）
- 特性：**元数据保护**；说明：❌ 用户 ID、请求 URI 暴露
- 特性：**政府访问**；说明：✅ 依法配合中国政府数据请求

**Citizen Lab 2024 年报告**：微信的加密实现与其 10 亿用户规模不匹配。

#### MTProto vs Signal Protocol

- 对比项：**设计年份**；MTProto 2.0：2013 年；Signal Protocol：2013 年
- 对比项：**默认 E2E**；MTProto 2.0：❌ 仅 Secret Chat；Signal Protocol：✅ 所有消息
- 对比项：**开源程度**；MTProto 2.0：规范公开，服务端闭源；Signal Protocol：完全开源
- 对比项：**加密模式**；MTProto 2.0：AES-256-IGE；Signal Protocol：AES-256-GCM
- 对比项：**密钥交换**；MTProto 2.0：DH + RSA；Signal Protocol：X3DH (Extended Triple DH)
- 对比项：**棘轮算法**；MTProto 2.0：简化版（每 100 条消息）；Signal Protocol：双棘轮（每条消息）
- 对比项：**量子安全**；MTProto 2.0：❌；Signal Protocol：✅ PQXDH（2024）
- 对比项：**学术认可**；MTProto 2.0：形式化验证通过；Signal Protocol：多篇论文分析

### 安全等级排名（2024）

```text
Level 3 ██████████████████████████ iMessage (PQ3)
Level 2 █████████████████████     Signal (PQXDH + SPQR)
Level 1 ███████████████           WhatsApp (Signal Protocol)
        ██████████████            Telegram Secret Chat (MTProto)
        ████████                  Telegram Cloud Chat
Level 0 ████                      微信 (MMTLS)
        ██                        Discord (仅 TLS)
```

> - **Level 3**：抵御当前和未来量子计算攻击 + 密钥泄露后恢复
> - **Level 2**：抵御量子攻击
> - **Level 1**：传统端到端加密
> - **Level 0**：仅传输加密或无加密

---

## 9. 安全争议与评价

### 正面评价

- 2017 年学术论文证明 MTProto 2.0 满足 IND-CCA 安全性
- 端到端加密通过形式化验证

### 争议与批评

- **自研协议**：未使用 Signal Protocol 等经过更广泛审计的协议
- **非默认 E2E**：普通聊天不启用端到端加密，引发隐私担忧
- **IGE 模式**：部分密码学家认为应使用 AEAD 模式（如 AES-GCM）

---

## 参考资料

### 官方文档

- MTProto 协议概述
  <https://core.telegram.org/mtproto>
- MTProto 详细描述
  <https://core.telegram.org/mtproto/description>
- 创建 Authorization Key
  <https://core.telegram.org/mtproto/auth_key>
- 端到端加密（Secret Chats）
  <https://core.telegram.org/api/end-to-end>
- TL 语言规范
  <https://core.telegram.org/mtproto/TL>
- 安全指南
  <https://core.telegram.org/mtproto/security_guidelines>

### 学术论文

- 年份：**2017**；论文：_Automated Symbolic Verification of Telegram's MTProto 2.0_
(Sec'17)；主要发现：形式化验证证明 MTProto 2.0 满足 IND-CCA 安全性
- 年份：**2021**；论文：_A Formal Security Analysis of the Signal Messaging
Protocol_；主要发现：Signal 协议的对比分析，指出 MTProto 的非默认 E2E 问题
- 年份：**2022**；论文：_Analysis of MTProto's Encryption Scheme_；主要发现：指出 IGE
模式的潜在风险，建议迁移到 AEAD

### 外部评估

- Crypto 101 - 密码学入门，解释 IGE 等模式
  <https://www.crypto101.io/>
- Moxie Marlinspike 对 Telegram 的评论 -
<https://twitter.com/maboroshi> Signal 创始人的批评视角
- ETH Zurich 安全分析 - MTProto 的符号验证项目
  <https://mtpsym.github.io/>

---

**最后更新**：2026 年 1 月
