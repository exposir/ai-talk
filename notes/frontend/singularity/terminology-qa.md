## 七、QA

> 导读：记录关键问答，回答基于本文既有内容与明确约束。

> 术语与定义已移至：`./specs-core.md#12-1-术语与定义`

### 7.1 目前世界上没有我这样的项目吗？如果有类似的，我这个就无意义了？

**答**：不是没有“类似点”，但目前看不到一个项目同时满足本文的关键约束。现有方案大多只覆盖单点能力：例如 XState 强在逻辑层，React Query 强在异步/缓存，Yjs 强在协作，Signal 生态强在细粒度更新。你的文档要解决的是“统一心智模型 + 逻辑/数据解耦 + 协作原生 + 可观测协议 + 迁移可行”的组合问题，这种整体性目前多依赖多库拼接而非单一体系。  
“无意义”与否不取决于“有没有类似”，而取决于你能否提供两个可验证的价值：  
1) **统一性**：用同一套原语覆盖本地/服务端/协作状态，减少模型切换与胶水代码；  
2) **迁移可行性**：让现有项目能渐进接入，而不是推倒重来。  
如果这两点在真实项目里成立，即便存在部分相似的方案，你的项目仍然有明确价值。

### 7.2 我的项目能否支持简单项目和超大型前端架构项目？

**答**：从文档目标与约束来看，设计是“可同时覆盖”，但成立与否取决于两条路径是否都能被验证。  
对**简单项目**，关键是“低心智、低配置、低体积”。文档中已经强调“渐进增强”“低配置成本”“可树摇”，并在路线图中把 `atom/computed/batch` 定义为最小可用原语。如果最终 API 能做到“只用 atom 也不需要理解机器/协作层”，并且默认性能足够，那就能胜任小项目。  
对**超大型项目**，关键是“可观测性、分域治理、一致性与性能”。如果你明确只面向未来新项目，**迁移路径不是必需条件**，但仍需要满足：  
1) **可观测性**覆盖跨团队协作的审计需求（时间线、回放、依赖图）。  
2) **分域治理**可让不同团队在边界内独立演进。  
3) **一致性与性能**在 1k+ 订阅、并发更新与 SSR 场景下稳定。  
因此，答案是“设计上可支持，但必须通过原型与真实项目验证”。若 M0/M1 demo 在小项目中保持极简体验，同时在大型架构中证明可观测与分域治理能力，那么两端都成立。

### 7.3 能否同时支持 Vue 和 React？

**答**：可以，但需要把“核心”与“适配器”严格分层。文档里已经定义了 `@singularity/core` 与框架适配器的包结构，这种架构天然支持多框架：  
1) **核心层**只负责状态原语、调度、可观测协议，不依赖任何框架；  
2) **适配器层**分别对接 React/Vue 的渲染与订阅机制。  
可行性取决于适配器的质量与一致性语义能否保持一致，但从架构上是可行且符合本文约束的。

### 7.4 心智模型和上手难度能否极为简易？

**答**：可以设计得极简，但前提是“默认路径足够短、进阶功能可推迟理解”。文档已强调“渐进增强”“低配置成本”和最小原语，这意味着新用户只需理解 `atom/computed/batch` 就能完成大多数小项目需求。  
难度的关键不在概念数量，而在**是否强迫理解复杂层**。只要状态机、协作、异步缓存都保持“按需启用”，并且默认案例不涉及它们，上手就能保持极简。  
所以，结论是“可以做到极简”，但需要在 API 设计与文档中明确**默认路径**与**进阶路径**的边界。

### 7.5 根据已经制定的方案和核心思想能否保证项目能制作出来？

**答**：方案与核心思想能显著提升“可实现性”，但不能保证“必然完成”。原因是实现还取决于工程执行、资源投入与高风险模块（协作、DevTools、性能基线）的验证结果。换句话说：**理念保证方向正确，工程决定是否落地**。因此结论是“具备可实现性，但仍需通过原型与里程碑验证来确保可交付”。

### 7.6 能否保证性能十分优异？如果性能一般一切都是空谈。

**答**：不能“保证”，但可以把性能作为硬性指标并通过基准对标确保领先。性能是否“十分优异”取决于三点：  
1) **基线目标是否足够高**（P95、内存与长期运行稳定性）；  
2) **对标是否严格**（同场景、同规模、同设备）；  
3) **实现是否持续优化**（依赖追踪、批处理、采样策略）。  
因此正确表述是：**性能必须领先，但需要基准与工程验证来兑现**，否则只会停留在口号层面。

---
