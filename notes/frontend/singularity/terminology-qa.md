## 六、术语与定义

> 导读：统一关键术语，减少歧义。

- **State Node**：可订阅、可组合的状态单元（atom/computed/async/sync）。
- **Batch**：在单一批次中合并多次写入并统一通知。
- **TraceEvent**：可观测事件流记录。


## 七、QA

> 导读：记录关键问答，回答基于本文既有内容与明确约束。

> 本节记录对话中的关键问答，回答基于本文既有内容与明确约束。

### 7.1 目前世界上没有我这样的项目吗？如果有类似的，我这个就无意义了？

**答**：不是没有“类似点”，但目前看不到一个项目同时满足本文的关键约束。现有方案大多只覆盖单点能力：例如 XState 强在逻辑层，React Query 强在异步/缓存，Yjs 强在协作，Signal 生态强在细粒度更新。你的文档要解决的是“统一心智模型 + 逻辑/数据解耦 + 协作原生 + 可观测协议 + 迁移可行”的组合问题，这种整体性目前多依赖多库拼接而非单一体系。  
“无意义”与否不取决于“有没有类似”，而取决于你能否提供两个可验证的价值：  
1) **统一性**：用同一套原语覆盖本地/服务端/协作状态，减少模型切换与胶水代码；  
2) **迁移可行性**：让现有项目能渐进接入，而不是推倒重来。  
如果这两点在真实项目里成立，即便存在部分相似的方案，你的项目仍然有明确价值。

### 7.2 我的项目能否支持简单项目和超大型前端架构项目？

**答**：从文档目标与约束来看，设计是“可同时覆盖”，但成立与否取决于两条路径是否都能被验证。  
对**简单项目**，关键是“低心智、低配置、低体积”。文档中已经强调“渐进增强”“低配置成本”“可树摇”，并在路线图中把 `atom/computed/batch` 定义为最小可用原语。如果最终 API 能做到“只用 atom 也不需要理解机器/协作层”，并且默认性能足够，那就能胜任小项目。  
对**超大型项目**，关键是“可观测性、分域治理、一致性与性能”。如果你明确只面向未来新项目，**迁移路径不是必需条件**，但仍需要满足：  
1) **可观测性**覆盖跨团队协作的审计需求（时间线、回放、依赖图）。  
2) **分域治理**可让不同团队在边界内独立演进。  
3) **一致性与性能**在 1k+ 订阅、并发更新与 SSR 场景下稳定。  
因此，答案是“设计上可支持，但必须通过原型与真实项目验证”。若 M0/M1 demo 在小项目中保持极简体验，同时在大型架构中证明可观测与分域治理能力，那么两端都成立。

### 7.3 能否同时支持 Vue 和 React？

**答**：可以，但需要把“核心”与“适配器”严格分层。文档里已经定义了 `@singularity/core` 与框架适配器的包结构，这种架构天然支持多框架：  
1) **核心层**只负责状态原语、调度、可观测协议，不依赖任何框架；  
2) **适配器层**分别对接 React/Vue 的渲染与订阅机制。  
可行性取决于适配器的质量与一致性语义能否保持一致，但从架构上是可行且符合本文约束的。

### 7.4 心智模型和上手难度能否极为简易？

**答**：可以设计得极简，但前提是“默认路径足够短、进阶功能可推迟理解”。文档已强调“渐进增强”“低配置成本”和最小原语，这意味着新用户只需理解 `atom/computed/batch` 就能完成大多数小项目需求。  
难度的关键不在概念数量，而在**是否强迫理解复杂层**。只要状态机、协作、异步缓存都保持“按需启用”，并且默认案例不涉及它们，上手就能保持极简。  
所以，结论是“可以做到极简”，但需要在 API 设计与文档中明确**默认路径**与**进阶路径**的边界。

---


> 导读：将实现拆成阶段，便于里程碑管理与风险控制。

### Phase 1: 核心原语 (Week 1-2)

- [ ] 实现 `atom()` - 基于 Signal 的响应式原子
- [ ] 实现 `computed()` - 派生状态
- [ ] 实现基础订阅机制
- [ ] 最小可观测性：变更日志与订阅统计接口

### Phase 2: 状态机集成 (Week 3-4)

- [ ] 实现 `machine()` - 轻量级 FSM
- [ ] 状态机与 atom 的绑定
- [ ] 副作用调度与取消语义 (effect lifecycle)
- [ ] 可视化工具接口

### Phase 3: 异步与服务端状态 (Week 5-6)

- [ ] 实现 `atomAsync()` - 异步数据获取
- [ ] 缓存策略与乐观更新
- [ ] 错误边界处理
- [ ] CRDT 兼容数据模型 PoC (验证序列化与合并策略)

### Phase 4: 协作支持 (Week 7-8)

- [ ] 实现 `atomSync()` - CRDT 集成
- [ ] Yjs 适配器
- [ ] 冲突解决策略

### Phase 5: 框架适配 (Week 9-10)

- [ ] React 适配器 (`@singularity/react`) - 最小可用版本
- [ ] DevTools 扩展
- [ ] Vue 适配器 (`@singularity/vue`)

### 里程碑 (M0/M1/M2)

- **M0 (Week 2)**：`atom()`/`computed()` 可用，最小可观测性完成
- **M1 (Week 6)**：`machine()`/`atomAsync()` 可用，effect 语义稳定
- **M2 (Week 10)**：`atomSync()` 与 React 适配器可用，DevTools 可用

### 关键风险与依赖

- **CRDT 设计前置**：数据模型一旦定型，后期改动成本高
- **调度一致性**：并发渲染/SSR 与异步取消语义要避免歧义
- **生态接入成本**：迁移策略与桥接层必须同时验证

### 交付风险与落地策略

**高风险 1：协作层 CRDT 性能与数据模型**
- **策略**：先做最小可用 PoC（小规模文档/少量字段），验证合并与回放。
- **交付保障**：CRDT 作为 M2 可选能力，默认关闭。

**高风险 2：DevTools 全量时间线性能**
- **策略**：默认启用 `minimal` 采样模式，仅记录 write/async 事件。
- **交付保障**：全量时间线作为实验功能，先保证导出与回放。

**高风险 3：异步缓存/取消/过期边界**
- **策略**：先锁定最小语义（去重 + 取消 + staleTime），不引入复杂策略。
- **交付保障**：复杂策略（重试退避、乐观回滚）后置到次版本。

### 里程碑验收标准

- **M0 通过**：原语 API 覆盖基本用例，变更日志可追踪，订阅统计可导出
- **M1 通过**：状态机/异步场景有最小示例，effect 生命周期文档清晰
- **M2 通过**：React 适配器完成最小 demo，DevTools 可查看状态轨迹

### Demo 场景清单

- **M0 Demo**：计数器 + 派生状态 + 批量更新演示
- **M1 Demo**：登录状态机 + 异步请求 + 取消与重试
- **M2 Demo**：多人协作文档 + React 组件集成 + DevTools 回放

### Demo 验收步骤

- **M0 Demo**：点击 100 次累计更新一次渲染，日志可导出为 JSON
- **M1 Demo**：触发登录后立即取消，状态机回到 idle 且无悬挂请求
- **M2 Demo**：两端同时编辑，冲突自动合并，时间线可回放

### 性能基线 (初版)

- **订阅开销**：1k 订阅下更新延迟稳定，可观测日志不显著拖慢渲染
- **批处理性能**：连续 1k 次更新合并为单次渲染
- **异步吞吐**：并发 100 个请求时取消语义稳定、无内存泄漏

### Benchmark 环境与口径 (初版)

- **环境**：MacBook Pro M1 / 16GB / Chrome Stable
- **场景**：1k 订阅、1k 连续更新、100 并发异步请求
- **口径**：使用 Performance API 统计更新耗时，记录均值与 P95

### Benchmark 采样脚本 (示例)

```typescript
// pseudo-benchmark for devtools panel or playground
const marks: number[] = [];

function measure(label: string, fn: () => void) {
  const start = performance.now();
  fn();
  const end = performance.now();
  marks.push(end - start);
  console.log(label, end - start);
}

measure('batch-1000', () => {
  batch(() => {
    for (let i = 0; i < 1000; i += 1) {
      counterAtom.set((n) => n + 1);
    }
  });
});

const p95 = marks.sort((a, b) => a - b)[Math.floor(marks.length * 0.95)];
console.log('p95', p95);
```

---

