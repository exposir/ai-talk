## 八、API 细节与一致性语义

> 导读：细化 API 与一致性语义，为实现提供硬规则。

### 8.1 状态类型与生命周期

- **atom**：可变的原子值，允许同步更新与订阅
- **computed**：派生值，依赖图自动追踪，只读
- **async atom**：带缓存与取消语义的异步状态
- **sync atom**：与 CRDT 绑定的协作状态，可选择离线合并

### 8.2 一致性语义 (初版)

- **读一致性**：同一批次内读到的是批次开始时的快照
- **写合并**：同一批次内多次写合并为一次通知
- **异步取消**：新请求触发时可取消旧请求，避免过期写入
- **协作合并**：冲突按 CRDT 规则合并，结果可回放

### 8.3 错误模型

- **同步错误**：抛出到调用方，可由边界组件捕获
- **异步错误**：保存在状态节点的 error 字段，可订阅
- **协作错误**：网络/合并失败以事件流暴露，不阻断本地写入

### 8.4 最小实现清单 (MVP)

- **核心**：atom/computed + 订阅 + 批处理
- **调度**：effect 生命周期与取消语义
- **可观测性**：变更日志 + 订阅统计 + 时间线接口
- **适配器**：React 最小 Hook 层

### 8.5 Async 缓存与失效策略 (初版)

- **缓存键**：`atomAsync(fetcher, { key })` 显式 key，避免隐式依赖
- **staleTime**：过期前读缓存，过期后返回缓存并触发刷新
- **cacheTime**：无人订阅后延迟回收
- **retry**：可配置重试次数与退避策略
- **optimistic**：允许先写入本地值，失败时回滚
- **dedupe**：同 key 并发请求合并为单次网络调用

### 8.6 DevTools 协议 (最小字段)

```typescript
type TraceEvent = {
  id: string;
  ts: number;
  type: 'read' | 'write' | 'effect' | 'async' | 'sync';
  nodeId: string;
  payload?: unknown;
  batchId?: string;
  error?: string;
};

type TraceSnapshot = {
  nodes: Record<string, unknown>;
  edges: Array<{ from: string; to: string }>;
};
```

### 8.7 SSR 与并发渲染语义 (初版)

- **请求隔离**：每个 SSR 请求拥有独立 store 实例
- **惰性初始化**：只有被访问的节点才创建
- **hydration**：客户端优先使用服务端快照，避免闪烁
- **并发一致性**：并发渲染中读到一致快照，提交后再触发通知

---


## 九、版本化与发布策略

> 导读：说明包结构与版本策略，明确发布节奏。

### 9.1 包结构

- `@singularity/core`：核心原语与调度
- `@singularity/react`：React 适配器
- `@singularity/devtools`：DevTools 协议与面板
- `@singularity/sync`：协作层 (CRDT 适配)

### 9.2 语义版本与兼容承诺

- **0.x**：API 可快速迭代，不保证兼容
- **1.0**：核心 API 稳定，破坏性变更按主版本发布
- **适配器**：与核心版本对齐，保持同一主版本

### 9.3 发布节奏

- **核心优先**：核心稳定后再扩展适配器与协作层
- **beta 通道**：提供 `-beta` 版本用于试验新语义

### 9.4 兼容与弃用策略

- **弃用周期**：至少一个次版本周期的 deprecate 提示
- **文档同步**：弃用说明与迁移指引同时发布
- **LTS**：核心稳定后可考虑 LTS 分支

---


## 十、文档结构建议

> 导读：规划对外文档结构，便于传播与使用。

### 10.1 快速上手

- 5 分钟入门：atom/computed/batch
- 第一个状态机 + 异步请求

### 10.2 概念模型

- State Node 抽象
- 逻辑层与数据层
- 一致性与调度语义

### 10.3 迁移指南

- Redux / Zustand / Jotai 迁移路径
- 共存与桥接策略

### 10.4 调试与性能

- DevTools 使用
- 性能基线与优化建议

### 10.5 文档组织建议

- **导航**：概念 > 快速上手 > API > 实践
- **版本**：每个版本保留对应文档快照

---


## 十一、文档评审与改进建议

> 导读：评审与反思区，不作为最终规范。

> 本章节为 AI 辅助生成的文档评审，旨在提供客观的质量评估与可执行的改进建议。

### 11.1 文档质量评估

| 维度         |    评分    | 评价                                   |
| :----------- | :--------: | :------------------------------------- |
| **完整性**   | ⭐⭐⭐⭐⭐ | 几乎涵盖了所有主流和小众方案，分类合理 |
| **深度**     |  ⭐⭐⭐⭐  | 每个库都有核心原理代码示例，非常实用   |
| **前瞻性**   | ⭐⭐⭐⭐⭐ | "奇点构想"部分有独到见解               |
| **实用性**   |  ⭐⭐⭐⭐  | 快速选择指南、迁移策略都很务实         |
| **可执行性** |   ⭐⭐⭐   | 路线图较乐观，需更多风险缓冲           |

### 11.2 核心亮点

1. **问题诊断精准**
   - 准确抓住"范式割裂"痛点：Zustand 管本地、React
     Query 管服务端、XState 管逻辑、Yjs 管协作——需要"组合拳"
   - "这个数据是服务端的还是客户端的？"这个问题每天困扰无数开发者

2. **"奇点"的定位清晰**

   ```
   统一心智模型 > 可观测性 > 逻辑/数据解耦 > 协作原生
   ```

   四个目标排序合理，体现了**从根本上解决问题**而非缝缝补补的思路。

3. **API 设计务实**
   ```typescript
   const docAtom = atomSync({ title: '', content: '' }, { id: 'doc:1' });
   ```
   "渐进增强"的 API 设计（`atom` → `atomAsync` → `atomSync`）是正确的方向。

### 11.3 潜在风险与建议

#### 风险 1：时间表过于乐观

- **问题**：10 周从零到 React 适配器 + DevTools + CRDT 协作？这几乎是不可能的
- **建议**：M0 周期翻倍，CRDT 集成作为 v1.1 而非 v1.0 目标

#### 风险 2："统一心智模型"的悖论

- **问题**：文档追求"一个抽象解决所有问题"，但历史证明——一旦抽象足够通用，它就会变得和 Redux 一样复杂
- **建议**：明确"不统一什么"——例如表单状态、动画状态可能就不该统一

#### 风险 3：Signal vs React 调和机制

- **问题**：文档提到"Signal 破坏 React 单向数据流哲学"，但又选择 Signal 作为核心
- **需解决**：
  - 如何与 `useTransition`、`Suspense` 等并发特性兼容？
- **建议**：增加一节"React 适配挑战"专门讨论此问题

#### 风险 4：缺少"失败条件"定义

- **问题**：路线图只定义了"如何成功"，没有定义"何时应该放弃"
  - 如果 M1 延期 4 周怎么办？
  - 如果 CRDT 集成证明不可行怎么办？
- **建议**：增加 Kill Criteria 章节

### 11.4 补充建议

#### 建议 1：增加"竞品跟踪"章节

- **Legend-State** 和 **TanStack Store**（Tanner
  Linsley 即将发布）都在朝类似方向努力
- 需要持续跟踪它们的进展，避免重复造轮子

#### 建议 2：增加"真实案例优先"策略

在写代码之前，先用现有库组合"模拟"出目标 API：

```typescript
// 用 Zustand + React Query + XState 组合，模拟出目标 API
const { atom, machine } = createNextStateSimulator(zustand, reactQuery, xstate);
```

这样可以**验证 API 设计是否真的解决问题**，再决定是否从头实现。

#### 建议 3：补充"渐进式采用"示例

企业不会一次性迁移。需要一个**可以和 Redux/Zustand 共存**的最小方案，而不是"全有或全无"。

```typescript
// 示例：桥接层允许新旧状态共存
import { bridge } from '@singularity/compat';

// 将现有 Zustand store 桥接为 State Node
const legacyCounter = bridge.zustand(useCounterStore);

// 新代码可以直接订阅
const double = computed(() => legacyCounter.get().count * 2);
```

#### 建议 4：调整里程碑节奏

| 原计划       | 建议调整            | 理由                     |
| :----------- | :------------------ | :----------------------- |
| M0 (Week 2)  | M0 (Week 4)         | 可观测性比预期复杂       |
| M1 (Week 6)  | M1 (Week 10)        | 异步取消语义需要充分测试 |
| M2 (Week 10) | M2 (Week 16) / v1.1 | CRDT 应作为独立版本发布  |

### 11.5 执行建议总结

1. **砍掉 50% 的范围**：先做好 `atom` + `computed` + React 适配器
2. **CRDT 作为 v2 目标**：不要在 v1 里冒险
3. **找一个真实项目试点**：用实际反馈驱动迭代
4. **增加竞品跟踪**：Legend-State / TanStack Store 的进展可能改变决策
5. **定义失败条件**：明确何时应该放弃或转向

---

