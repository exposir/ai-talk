<!--
- [INPUT]: 依赖无，基于用户提供的课程核心理念
- [OUTPUT]: 对外提供第一章课程内容：Agent 核心概念与技术栈选择
- [POS]: ai-agent-fullstack-course 的第一章
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 第一章：AI Agent 开发要学什么？—— 从大模型到智能体

> "神说要有光。" 在 AI 的世界里，Agent 就是让光照进现实的介质。

## 1. 为什么我们需要 AI Agent？

我们每天都在使用各种 AI 工具，比如用 Cursor 写代码，用 Manus 处理自动化任务。但你有没有想过，这些工具背后的原理是什么？为什么我们不能直接调用大模型（LLM）的 API 来完成所有事情？

### 大模型（LLM）的 "阿喀琉斯之踵"

如果直接与裸奔的大模型对话，你会发现它存在三个致命缺陷：

1.  **"失忆症" (No Memory)**：
    - _现象_：你上周和它聊过的项目细节，今天它全忘了。
    - _原因_：LLM 是无状态的，每一次请求都是全新的。
    - _需求_：我们需要 **Memory（记忆管理）** 来维护对话上下文。

2.  **"与世隔绝" (No Tools)**：
    - _现象_：你让它帮你访问一个网页总结内容，或者查询今天的股票价格，它只能无奈地告诉你"我无法访问互联网"。
    - _原因_：LLM 是一个被训练好的静态模型，无法主动感知外部世界或执行操作。
    - _需求_：我们需要 **Tools（工具调用）**
      让它有了"手脚"，去联网、去操作数据库、去点击浏览器。

3.  **"幻觉与知识盲区" (No Private Knowledge)**：
    - _现象_：你问它公司内部的 "阿波罗计划" 进度如何，它可能会一本正经地胡说八道（幻觉），或者直接说不知道。
    - _原因_：它的训练数据截止于过去，且不包含你的私有数据。
    - _需求_：我们需要 **RAG（检索增强生成）**
      就像给它外挂了一个实时更新的图书馆。

**结论**：不管大模型如何进化，_记忆管理_、_工具使用_、_私有知识查询_
永远是应用层开发者的核心阵地。这就是我们要学习 AI Agent 开发的原因。

---

## 2. 什么是 Agent？

**公式定义**：

> **Agent = LLM（大脑）+ Memory（记忆）+ Tools（手脚）+ Planning（规划）**

Agent（智能体）本质上是一个以大模型为核心控制器，具备感知、记忆、规划和行动能力的系统。

- **思考与规划 (Planning)**：LLM 负责拆解任务（例如："要写一份竞品分析"
  -> 1.搜索竞品 -> 2.阅读网页 -> 3.总结对比）。
- **行动 (Tools)**：LLM 决定调用浏览器工具访问网页，或者调用文件工具写入 Markdown。
- **记忆 (Memory)**：记住用户的目标和已经完成的步骤，确保持续执行。
- **知识 (RAG)**：在行动过程中查询必要的背景信息。

### 现实案例解析

- **Manus**: 当它帮你打开浏览器、点击元素、总结文档时，它是通过 **Tools**
  扩展了浏览器操作能力。
- **支付宝"蚂小财"**: 当它分析基金数据时，它不是靠模型训练记住的（数据每天变），而是通过
  **RAG/Tools** 实时查询了基金数据库。

---

## 3. 技术栈选型：前端视角的 AI 全栈

我们要开发的不仅仅是一个聊天机器人，而是一个能解决实际问题的 **AI 全栈产品**。

### 核心框架

1.  **LangChain (Node.js 版)**：
    - _定位_：Agent 开发的"瑞士军刀"。
    - _用途_：封装了模型调用、Prompt 模板、RAG 检索、工具链等底层能力。
    - _场景_：开发单个 Agent，处理标准化的任务流。

2.  **LangGraph**：
    - _定位_：多 Agent 协作的"指挥官"。
    - _用途_：处理复杂的、有状态的、循环的工作流。
    - _场景_：当任务复杂到需要一个 Agent 写代码，另一个 Agent 审核代码，通过复杂的循环交互来完成时，LangGraph 是必选方案。

3.  **开发语言：Node.js / TypeScript**：
    - 虽然 Python 在 AI 训练界是老大，但在 AI **应用开发**
      界，Node.js 具备巨大优势。
    - 前端工程师可以无缝衔接，逻辑与概念与 Python 版完全一致。

### 后端支撑 (AI 全栈)

Agent 不仅仅是在前端跑的逻辑，它通过需要强大的后端支撑：

- **Runtime**: Node.js (NestJS)
- **Memory Store**: Redis (存储短期对话历史)
- **Vector Store**: PostgreSQL (pgvector) 或 ChromaDB (存储 RAG 向量知识)

## 4. 课程目标

本课程将采用 **Node.js + LangChain + LangGraph** 的技术栈，带你从零实现：

1.  给大模型装上 **Memory**，让它记住你的偏好。
2.  给大模型配备 **Tools**，让它能联网、操作文件。
3.  搭建 **RAG** 系统，让大模型读懂你的私有文档。
4.  开发 **Multi-Agent** 系统，让多个 AI 智能体协作完成复杂任务。

**Next Step**: 准备好你的 Node.js 环境，我们开始起飞。
